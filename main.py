import asyncio
import logging
import sys
from datetime import datetime, timedelta

from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, FSInputFile, ContentType
from aiogram.types.web_app_info import WebAppInfo   
from aiogram.filters import Command

# from gen_message import generate_messange
from client import Client
from api import TOKEN

# All handlers should be attached to the Router (or Dispatcher)

dp = Dispatcher()
cl = Client()




@dp.message(CommandStart())
async def command_start_handler(message: Message) -> None:
    """
    This handler receives messages with `/start` command
    """
    greeting = '''
–í–∞—à –ª–∏—á–Ω—ã–π –º—É–ª—å—Ç–∏—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ —Å –¥–æ—Å—Ç—É–ø–æ–º –∫ –ª—É—á—à–∏–º —è–∑—ã–∫–æ–≤—ã–º –º–æ–¥–µ–ª—è–º –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞!

üìå –ß—Ç–æ —É–º–µ–µ—Ç –±–æ—Ç:

–û–±—â–µ–Ω–∏–µ –∏ –ø–æ–º–æ—â—å: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–æ—â—å ChatGPT, DeepSeek, Gemini –∏ GigaChat –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á, –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–¥–µ–π, –Ω–∞–ø–∏—Å–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤, –æ–±—É—á–µ–Ω–∏—è –∏ –º–Ω–æ–≥–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ.

–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: –ì–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é DALL-E –ø–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É.

–ú—É–ª—å—Ç–∏–º–æ–¥–µ–ª—å–Ω–æ—Å—Ç—å: –í—ã–±–∏—Ä–∞–π—Ç–µ, –∫–∞–∫–∞—è –º–æ–¥–µ–ª—å –ª—É—á—à–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –≤–∞—à–µ–π –∑–∞–¥–∞—á–∏, –∏–ª–∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–π—Ç–µ –æ—Ç–≤–µ—Ç—ã –æ—Ç —Ä–∞–∑–Ω—ã—Ö –ò–ò.

–£–¥–æ–±—Å—Ç–≤–æ: –í—Å–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ AI –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ, –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä—è–º–æ –≤ Telegram.

‚ú® –ü–æ—á–µ–º—É —ç—Ç–æ—Ç –±–æ—Ç?

–ú–æ—â—å –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö AI: –ë–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç—å—Å—è –º–µ–∂–¥—É —Å–µ—Ä–≤–∏—Å–∞–º–∏ ‚Äî –≤—Å—ë –≤ –æ–¥–Ω–æ–º –±–æ—Ç–µ.

–ü—Ä–æ—Å—Ç–æ—Ç–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è: –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã.

–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç—å: –ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã, —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–∞, –æ–±—É—á–µ–Ω–∏—è –∏ —Ä–∞–∑–≤–ª–µ—á–µ–Ω–∏–π.

üöÄ –ù–∞—á–Ω–∏—Ç–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!
–û—Ç–ø—Ä–∞–≤—å—Ç–µ –±–æ—Ç—É –∑–∞–ø—Ä–æ—Å, –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏ –ø–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç. –°–æ–∑–¥–∞–≤–∞–π—Ç–µ —Ç–µ–∫—Å—Ç—ã, –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, —Ä–µ—à–∞–π—Ç–µ –∑–∞–¥–∞—á–∏ –∏ –æ—Ç–∫—Ä—ã–≤–∞–π—Ç–µ –Ω–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å AI!

üëâ –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ Telegram –∏ —Å—Ç–∞–Ω—å—Ç–µ —á–∞—Å—Ç—å—é –±—É–¥—É—â–µ–≥–æ —É–∂–µ —Å–µ–≥–æ–¥–Ω—è!

/start - –ù–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ —Å –±–æ—Ç–æ–º
/help - –ü–æ–ª—É—á–∏—Ç—å –ø–æ–º–æ—â—å –∏ —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
/subscription - –æ—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –∏ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–±–æ—Ç—É –±–æ—Ç–∞
/gen_image *–≤–∞—à –ø—Ä–æ–º–ø—Ç* - —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É
/gen_sound *–≤–∞—à –ø—Ä–æ–º–ø—Ç* - —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
/choose_model - –≤—ã–±–æ—Ä –º–æ–¥–µ–ª–∏
/clear_context - –æ—á–∏—Å—Ç–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç

–£–¥–∞—á–∏ –∏ —É—Å–ø–µ—Ö–∞ –≤ —Ç–≤–æ–∏—Ö –Ω–∞—á–∏–Ω–∞–Ω–∏—è—Ö! üíªüéâ
'''
    await message.answer(greeting)
    
    
    cl.model.new_user(tgID=message.from_user.id, name=message.from_user.full_name, date_start=datetime.now(), model=5, imageModel=8)
# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
@dp.message(Command("subscription"))
async def cmd_buy(message: Message):
    
    buttons = [[InlineKeyboardButton(text="–ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ (7 –¥–Ω–µ–π)", callback_data="limited")],
                [InlineKeyboardButton(text="–ë–µ—Å—Å—Ä–æ—á–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞", callback_data="unlimited")]
        ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons, row_width=2)
    
    await message.answer(f'–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É', reply_markup=keyboard)
    
# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ callback –∑–∞–ø—Ä–æ—Å–æ–≤
@dp.callback_query(lambda c: c.data in ["limited", "unlimited"])
async def process_callback_answer(callback_query: CallbackQuery):
    if callback_query.data == 'unlimited':
        # —Å–æ–∑–¥–∞–µ–º –ø–ª–∞—Ç–µ–∂
        payment_url = cl.create_check(tgID=callback_query.from_user.id, value='1', description='1')
        if payment_url == '—É –≤–∞—Å –µ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∞':
            await callback_query.answer(f'‚úÖ –£ –≤–∞—Å —É–∂–µ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞')
            await callback_query.message.edit_text(f'‚úÖ –£ –≤–∞—Å —É–∂–µ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞')
        else:
            print('payment_url')
            buttons = [[InlineKeyboardButton(text="–û–ø–ª–∞—Ç–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É",web_app=WebAppInfo(url=payment_url))],
                    [InlineKeyboardButton(text="–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É", callback_data="confirm_subscription")]
            ]
            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons, row_width=2)
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π
            await callback_query.answer(f'–°–æ–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –ø–æ–¥–ø–∏—Å–∫–∏ 1 —Ä—É–±.', reply_markup=keyboard)
            await callback_query.message.edit_text(f'–°–æ–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –ø–æ–¥–ø–∏—Å–∫–∏ 1 —Ä—É–±.', reply_markup=keyboard)
    else:
        has_lim_sub = cl.model.select_lim(callback_query.from_user.id, 'hasLimitedSubscription')
        if has_lim_sub == 1:
            # –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞ –∏ –≤—Ä–µ–º—è
            now = datetime.now()

            # –î–æ–±–∞–≤–ª—è–µ–º 7 –¥–Ω–µ–π
            end_date = now + timedelta(days=7)
            
            cl.model.add_subscriptions(2, callback_query.from_user.id, end_Date=end_date)
            await callback_query.answer(f'–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –ø—Ä–æ–±–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞')
            await callback_query.message.edit_text(f'–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –ø—Ä–æ–±–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞')
            cl.model.update_lim(callback_query.from_user.id, 'hasLimitedSubscription')
        else:
            await callback_query.message.edit_text(f'–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ —Ç–µ—Å—Ç–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É')

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ callback –∑–∞–ø—Ä–æ—Å–æ–≤
@dp.callback_query(lambda c: c.data == 'confirm_subscription')
async def process_callback_answer(callback_query: CallbackQuery):
     tgID = callback_query.from_user.id
     payment_id = cl.model.get_payment_id(tgID, 1)
     payment_status = cl.payments.check_payment_status(payment_id=payment_id)
     if payment_status == 'succeeded':
        cl.model.update_payment_status(payment_status, payment_id)
        cl.model.add_subscriptions(1, tgID, payment_id)
        await callback_query.answer(f"–æ–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞")
        await callback_query.message.edit_text(f"–æ–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", reply_markup=None)

@dp.message(Command("choose_model"))
async def choose_model(message: Message):
    has_subscription = cl.model.check_user_subscription(message.from_user.id)
    if 1 in has_subscription:
        buttons = [[InlineKeyboardButton(text="Sber GigaChat", callback_data="Sber GigaChat")],
            [InlineKeyboardButton(text="OpenAI GPT-4.0", callback_data="OpenAI GPT-4.0")],
            [InlineKeyboardButton(text="OpenAI o1", callback_data="OpenAI o1")],
            [InlineKeyboardButton(text="Google Gemini", callback_data="Google Gemini")],
            [InlineKeyboardButton(text="Deepseek", callback_data="Deepseek")],
            [InlineKeyboardButton(text="DALL-E 3.0", callback_data="DALL-E 3.0")],
            [InlineKeyboardButton(text="Sber GigaChat –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π", callback_data="Sber GigaChat –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")],
            [InlineKeyboardButton(text="dall-e-2", callback_data="dall-e-2")],
            [InlineKeyboardButton(text="tts-1", callback_data="tts-1")],
            [InlineKeyboardButton(text="tts-1-hd", callback_data="tts-1-hd")]
        ]
    else:
        buttons = [[InlineKeyboardButton(text="Sber GigaChat", callback_data="Sber GigaChat")],
            [InlineKeyboardButton(text="Sber GigaChat –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π", callback_data="Sber GigaChat –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")],
            [InlineKeyboardButton(text="DALL-E 3.0", callback_data="DALL-E 3.0")],
            [InlineKeyboardButton(text="dall-e-2", callback_data="dall-e-2")]
        ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons, row_width=2)
    await message.answer('–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å', reply_markup=keyboard)

@dp.callback_query(lambda c: c.data in ["Sber GigaChat", "OpenAI GPT-4.0", "OpenAI o1", "Google Gemini", "Deepseek",  "DALL-E 3.0", "Sber GigaChat –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π", "dall-e-2", "tts-1", "tts-1-hd"])
async def process_callback(callback_query: CallbackQuery):
    tgID = callback_query.from_user.id
    model = callback_query.data

    await callback_query.answer(f'–í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å: {model}')
    await callback_query.message.edit_text(f'–í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å: {model}', reply_markup=None)

    models = {
    "OpenAI GPT-4.0": {
        "id": 1,
        "column": "model"
    },
    "OpenAI o1": {
        "id": 2,
        "column": "model"
    },
    "Google Gemini": {
        "id": 3,
        "column": "model"
    },
    "Deepseek": {
        "id": 4,
        "column": "model"
    },
    "Sber GigaChat": {
        "id": 5,
        "column": "model"
    },
    "DALL-E 3.0": {
        "id": 6,
        "column": "imageModel"
    },
    "Sber GigaChat –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π": {
        "id": 7,
        "column": "imageModel"
    },
    "dall-e-2": {
        "id": 8,
        "column": "imageModel"
    },
    "tts-1": {
        "id": 9,
        "column": "audioModel"
    },
    "tts-1-hd": {
        "id": 10,
        "column": "audioModel"
    }
}
        
    cl.model.change_model(tgID=tgID, model=models[model]['id'], column=models[model]['column'])


@dp.message(Command("gen_image"))
async def img(message: Message):
    amount = '5'
    tgID = message.from_user.id
    prompt = message.text
    
    if prompt == '/gen_image':
        await message.answer(f'üé® –ß—Ç–æ–±—ã —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /gen_image –¥–æ–±–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ')
    else:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        has_free_pic = cl.model.select_lim(tgID, 'hasFreePicture')
        paymentID, payment_url = cl.create_check(tgID=tgID, value=amount, description='2')
        
        # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏
        buttons = [
            [InlineKeyboardButton(text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", web_app=WebAppInfo(url=payment_url))],
            [InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É", callback_data=f"confirm_image:{paymentID}")]
        ]
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø—Ä–æ–º–ø—Ç–æ–º –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏—è—Ö
        await message.answer(f'üé® –í–∞—à –ø—Ä–æ–º–ø—Ç: {prompt}')
    
        
        # –ï—Å–ª–∏ –µ—Å—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏, –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        if has_free_pic > 1:
            buttons.append([InlineKeyboardButton(text="üÜì –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é", callback_data=f"use_free_image:{paymentID}")])
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        cl.model.add_image(tgID, paymentID, prompt)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏
        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons, row_width=2)
        await message.answer(f"""üéÅ –£ –≤–∞—Å –µ—Å—Ç—å {has_free_pic} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.
    üí∏ –ü—Ä–æ–≤–µ–¥–∏—Ç–µ –æ–ø–ª–∞—Ç—É –≤ —Ä–∞–∑–º–µ—Ä–µ {amount} —Ä—É–±–ª–µ–π""", reply_markup=keyboard)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ callback –∑–∞–ø—Ä–æ—Å–æ–≤
@dp.callback_query(lambda c: c.data.startswith(('confirm_image:', 'use_free_image:')))
async def process_callback_answer(callback_query: CallbackQuery):
    tgID = callback_query.from_user.id
    action, paymentID = callback_query.data.split(':')
    
    if action == "confirm_image":
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã
        payment_status = cl.payments.check_payment_status(payment_id=paymentID)
        if payment_status == 'succeeded':
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ –Ω–∞—á–∞–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            await callback_query.message.answer("üîÑ –ù–∞—á–∏–Ω–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...")
            
            cl.model.update_payment_status(payment_status, paymentID)
            prompt = cl.model.get_prompt_by_payment_id(paymentID)
            image_url = cl.take_image(tgID, prompt)
            # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª –≤ –±–∏–Ω–∞—Ä–Ω–æ–º —Ä–µ–∂–∏–º–µ
            content = FSInputFile('content.jpg')
            await callback_query.message.answer_photo(photo=content)
            await callback_query.answer(f"‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞")
            await callback_query.message.edit_text(f"‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", reply_markup=None)
            cl.model.update_image_url(paymentID, image_url)
        else:
            await callback_query.answer(f"‚ùå –û–ø–ª–∞—Ç–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞")
    
    elif action == "use_free_image":
        has_free_pic = cl.model.select_lim(tgID, 'hasFreePicture')
        if has_free_pic == 0:
            await callback_query.answer(f"üéâ –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞")
        else: 
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ –Ω–∞—á–∞–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            await callback_query.message.answer("üîÑ –ù–∞—á–∏–Ω–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...")
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            prompt = cl.model.get_prompt_by_payment_id(paymentID)
            image_url= cl.take_image(tgID, prompt)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            cl.model.update_lim(tgID, 'hasFreePicture', has_free_pic - 1)  # –£–º–µ–Ω—å—à–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π
            content = FSInputFile('files/images/output/content.jpg')
            await callback_query.message.answer_photo(photo=content)
            await callback_query.answer(f"üéâ –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞")
            await callback_query.message.edit_text(f"üéâ –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞", reply_markup=None)
            cl.model.update_image_url(paymentID, image_url)

@dp.message(Command("help"))
async def cmd_help(message: Message):
    help_message = '''
/buy - –æ—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –∏ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–±–æ—Ç—É –±–æ—Ç–∞
/gen_image - —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É –ü–û–ö–ê –ù–ï –†–ê–ë–û–¢–ê–ï–¢
/choose_model - –≤—ã–±–æ—Ä –º–æ–¥–µ–ª–∏
/clear_context - –æ—á–∏—Å—Ç–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç
—Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞ - @zdarova_69
        '''
    await message.reply(help_message)

@dp.message(Command("clear_context"))
async def cmd_clear_context(message: Message):
    cl.model.update_context_clear(message.from_user.id)
    await message.reply('–∫–æ–Ω—Ç–µ–∫—Å—Ç –æ—á–∏—â–µ–Ω! ‚úÖ')


@dp.message(F.content_type == ContentType.PHOTO)
async def photo_handler(message: Message):
    image_path = "files/images/input/input.jpg"
    prompt=message.caption
    # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
    await message.bot.download(file=message.photo[-1].file_id, destination=image_path)

    answer = cl.answer_photo(tgID=message.from_user.id, photo=image_path, prompt=prompt)
    await message.reply(answer)


@dp.message()
async def message_handler(message: Message) -> None:
    """
    Handler will forward receive a message back to the sender

    By default, message handler will handle all message types (like a text, photo, sticker etc.)
    """
    # try:
        # Send a copy of the received message
    print(message.text)
    answer = cl.generate_answer(tgID=message.from_user.id ,prompt=message.text)
    await message.reply(answer)
    # except TypeError:
    #     # But not all the types is supported to be copied so need to handle it
    #     await message.answer("Nice try!")


async def main() -> None:
    # Initialize Bot instance with default bot properties which will be passed to all API calls
    bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))

    # And the run events dispatching
    await dp.start_polling(bot)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, stream=sys.stdout)
    asyncio.run(main())